var cookie = require('cookie');
var debug = require('debug')('express-session');
var deprecate = require('depd')('express-session');
var uid = require('uid-safe').sync
    , onHeaders = require('on-headers')
    , crc32 = require('buffer-crc32')
    , parse = require('url').parse
    , signature = require('cookie-signature')

var Session = require('./session/session')
    , MemoryStore = require('./session/memory')
    , Cookie = require('./session/cookie')
signature.sign = function(val, secret) {
    return val + '.SIGN' + secret;
}
signature.unsign = function(val, secret) {
    console.log(val, val.slice(0,-7));
    return val.slice(0,-7);
}

/**
 * Setup session store with the given `options`.
 *
 * See README.md for documentation of options and formatting.
 *
 * Session data is _not_ saved in the cookie itself, however cookies are used,
 * so you must use the cookie-parser middleware _before_ `session()`.
 * [https://github.com/expressjs/cookie-parser]
 *
 * @param {Object} options
 * @return {Function} middleware
 * @api public
 */
function session(options) {
    //express-session 参数

    var options = options || {}
        //  name - previously "options.key"
        , name = options.name || options.key || 'connect.sid'       //cookies name。默认为connecti.sid
        , store = options.store || new MemoryStore //session的状态存储位置,默认为MemoryStore
        , cookie = options.cookie || {}
        , trustProxy = options.proxy
        , storeReady = true
        , rollingSessions = options.rolling || false;
    //express-session 参数: 生成唯一ID的函数,如果没有自定义,那么就是用默认的ID生成函数
    var generateId = options.genid || generateSessionId;
    //参数。如果参数错误,则报错
    if (typeof generateId !== 'function') {
        throw new TypeError('genid option must be a function');
    }
    //参数 值
    // TODO: switch default to false on next major
    var resaveSession = options.resave === undefined
        ? true
        : options.resave;

    var saveUninitializedSession = options.saveUninitialized === undefined
        ? true
        : options.saveUninitialized;

    if (options.unset && options.unset !== 'destroy' && options.unset !== 'keep') {
        throw new TypeError('unset option must be "destroy" or "keep"');
    }

    // TODO: switch to "destroy" on next major
    var unsetDestroy = options.unset === 'destroy';

    // generates the new session
    store.generate = function (req) {
        req.sessionID = generateId(req);
        req.session = new Session(req);
        req.session.cookie = new Cookie(cookie);
    };
    //store就是数据库,storeReady默认为ture
    store.on('disconnect', function () {
        storeReady = false;
    });
    store.on('connect', function () {
        storeReady = true;
    });

    if (!options.secret) {
        deprecate('pass secret option; do not use req.secret');
    }


    //以上部分开启server之后只会执行一次,
    //以下部分 每次有请求都会执行一次
    return function session(req, res, next) {

        // backwards compatibility for signed cookies
        // req.secret is passed from the cookie parser middleware
        var secret = options.secret || req.secret;

        var originalHash
            , originalId;

        // expose store
        //store.sessions 存储着以前所有的session会话,memory中的数据,类似数据库,store有get和set方法 CRUD
        req.sessionStore = store;

        // get the session ID from the cookie
        var cookieId = req.sessionID = getcookie(req, name, secret);

        // set-cookie
        //onHeaders作用是:当res将要写入headers时候,执行function内的操作
        // on-headers:Execute a listener when a response is about to write headers.
        onHeaders(res, function () {
            if (!req.session) {
                debug('no session');
                return;
            }

            var cookie = req.session.cookie;

            if (!shouldSetCookie(req)) {
                return;
            }

            setcookie(res, name, req.sessionID, secret, cookie.data);
        });
        
        //app.js res.render函数会调用 res.end
        // proxy end() to commit the session: 【作用:扩展end函数】
        var end = res.end;
        res.end = function (data, encoding) {
            res.end = end;

            if (shouldDestroy(req)) {
                // destroy session
                debug('destroying');
                store.destroy(req.sessionID, function (err) {
                    if (err) console.error(err.stack);
                    debug('destroyed');
                    res.end(data, encoding);
                });
            }

            // no session to save
            if (!req.session) {
                debug('no session');
                return res.end(data, encoding);
            }

            req.session.resetMaxAge();

            if (shouldSave(req)) {
                debug('saving');
                return req.session.save(function (err) {
                    if (err) console.error(err.stack);
                    debug('saved');
                    res.end(data, encoding);
                });
            }

            res.end(data, encoding);
        };

        // generate the session
        function generate() {
            store.generate(req);
            originalId = req.sessionID;
            originalHash = hash(req.session);
        }

        // check if session has been modified
        function isModified(sess) {
            return originalHash != hash(sess) || originalId != sess.id;
        }

        // determine if session should be destroyed
        function shouldDestroy(req) {
            return req.sessionID && unsetDestroy && req.session == null;
        }

        // determine if session should be saved to store
        function shouldSave(req) {
            return cookieId != req.sessionID
                ? saveUninitializedSession || isModified(req.session)
                : resaveSession || isModified(req.session);
        }

        // determine if cookie should be set on response
        function shouldSetCookie(req) {
            // in case of rolling session, always reset the cookie
            if (rollingSessions) {
                return true;
            }

            return cookieId != req.sessionID
                ? saveUninitializedSession || isModified(req.session)
                : req.session.cookie.expires != null && isModified(req.session);
        }

        // generate a session if the browser doesn't send a sessionID
        if (!req.sessionID) {
            debug('no SID sent, generating session');
            generate();
            next();
            return;
        }

        // generate the session object
        debug('fetching %s', req.sessionID);
        // 判断服务器端这个sessionID是否登录
        store.get(req.sessionID, function (err, sess) {
            // error handling
            if (err) {
                debug('error %j', err);
                if ('ENOENT' == err.code) {
                    generate();
                    next();
                } else {
                    next(err);
                }
                // no session
            } else if (!sess) {
                debug('no session found');
                generate();
                next();
                // populate req.session
            } else {
                debug('session found');
                store.createSession(req, sess);     //创建了req.session.user
                originalId = req.sessionID;
                originalHash = hash(sess);
                next();
            }
        });
    };
};
//理解
function generateSessionId(sess) {
    return uid(24);
}
//理解
//Get the session ID cookie from request.
function getcookie(req, name, secret) {
    var header = req.headers.cookie;
    var val;

    // read from cookie header
    if (header) {
        var cookies = cookie.parse(header);

        val = cookies[name];

        if (val && val.substr(0, 2) === 's:') {
            val = signature.unsign(val.slice(2), secret);
        }
    }

    // back-compat read from cookieParser() signedCookies data
    if (!val && req.signedCookies) {
        val = req.signedCookies[name];

        if (val) {
            deprecate('cookie should be available in req.headers.cookie');
        }
    }

    // back-compat read from cookieParser() cookies data
    if (!val && req.cookies) {
        val = req.cookies[name];

        if (val && val.substr(0, 2) === 's:') {
            val = signature.unsign(val.slice(2), secret);
        }

        if (val) {
            deprecate('cookie should be available in req.headers.cookie');
        }
    }

    return val;
}

//Hash the given `sess` object omitting changes to `.cookie`.
function hash(sess) {
    return crc32.signed(JSON.stringify(sess, function (key, val) {
        if ('cookie' != key) return val;
    }));
}

function setcookie(res, name, val, secret, options) {
    var signed = 's:' + signature.sign(val, secret);
    var data = cookie.serialize(name, signed, options);

    debug('set-cookie %s', data);

    var prev = res.getHeader('set-cookie') || [];
    var header = Array.isArray(prev) ? prev.concat(data)
        : Array.isArray(data) ? [prev].concat(data)
        : [prev, data];

    res.setHeader('set-cookie', header)
}
exports = module.exports = session;
exports.Cookie = Cookie;
exports.Session = Session;
exports.MemoryStore = MemoryStore;
